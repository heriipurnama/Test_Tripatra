package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"fmt"
	"procurement-app-backend/handlers"
	"procurement-app-backend/models"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// CreatePurchaseOrder is the resolver for the createPurchaseOrder field.
func (r *mutationResolver) CreatePurchaseOrder(ctx context.Context, userID string, items []*models.ItemInput) (*models.PurchaseOrder, error) {
	// panic(fmt.Errorf("not implemented: CreatePurchaseOrder - createPurchaseOrder"))
	var itemList []models.Item
	totalAmount := 0.0
	for _, item := range items {
		totalAmount += float64(item.Quantity) * item.Price
		itemList = append(itemList, models.Item{
			ItemID:   item.ItemID,
			Name:     item.Name,
			Quantity: item.Quantity,
			Price:    item.Price,
		})
	}

	purchaseOrder := &models.PurchaseOrder{
		OrderID:     primitive.NewObjectID().Hex(),
		UserID:      userID,
		Items:       itemList,
		TotalAmount: totalAmount,
		CreatedAt:   time.Now(),
	}

	_, err := collection.InsertOne(ctx, purchaseOrder)
	if err != nil {
		return nil, err
	}

	// go utils.SendEmail(userID, "Purchase Order Created", "Your purchase order has been successfully created.")

	return purchaseOrder, nil
}

// GenerateReport is the resolver for the generateReport field.
func (r *mutationResolver) GenerateReport(ctx context.Context, orderID string) (*models.Report, error) {
	panic(fmt.Errorf("not implemented: GenerateReport - generateReport"))
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, name string, email string, password string) (*models.User, error) {
	// panic(fmt.Errorf("not implemented: Register - register"))
	return handlers.Register(ctx, name, email, password)
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*models.LoginResponse, error) {
	response, err := handlers.Login(ctx, email, password)
	if err != nil {
		return nil, err
	}
	return response, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *purchaseOrderResolver) CreatedAt(ctx context.Context, obj *models.PurchaseOrder) (string, error) {
	// panic(fmt.Errorf("not implemented: CreatedAt - createdAt"))
	createdAtString := obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00")

	return createdAtString, nil
}

// GetPurchaseOrders is the resolver for the getPurchaseOrders field.
func (r *queryResolver) GetPurchaseOrders(ctx context.Context) ([]*models.PurchaseOrder, error) {
	// Define a slice to store the results
	var purchaseOrders []*models.PurchaseOrder

	// Find all documents in the collection
	cursor, err := collection.Find(ctx, bson.D{})
	if err != nil {
		return nil, err
	}
	defer cursor.Close(ctx)

	// Iterate over the cursor and decode each document into a PurchaseOrder struct
	for cursor.Next(ctx) {
		var po models.PurchaseOrder
		if err := cursor.Decode(&po); err != nil {
			return nil, err
		}
		purchaseOrders = append(purchaseOrders, &po)
	}

	// Check for any errors during cursor iteration
	if err := cursor.Err(); err != nil {
		return nil, err
	}

	// Return the slice of PurchaseOrder structs
	return purchaseOrders, nil
}

// GetReport is the resolver for the getReport field.
func (r *queryResolver) GetReport(ctx context.Context, orderID string) (*models.Report, error) {
	panic(fmt.Errorf("not implemented: GetReport - getReport"))
}

// GeneratedAt is the resolver for the generatedAt field.
func (r *reportResolver) GeneratedAt(ctx context.Context, obj *models.Report) (string, error) {
	panic(fmt.Errorf("not implemented: GeneratedAt - generatedAt"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// PurchaseOrder returns PurchaseOrderResolver implementation.
func (r *Resolver) PurchaseOrder() PurchaseOrderResolver { return &purchaseOrderResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Report returns ReportResolver implementation.
func (r *Resolver) Report() ReportResolver { return &reportResolver{r} }

type mutationResolver struct{ *Resolver }
type purchaseOrderResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type reportResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *loginResponseResolver) User(ctx context.Context, obj *models.LoginResponse) (*models.User, error) {
	return &obj.User, nil
}

type loginResponseResolver struct{ *Resolver }

var collection *mongo.Collection

func init() {
	// Replace "your_database_name" and "your_collection_name" with your actual database and collection names
	clientOptions := options.Client().ApplyURI("mongodb://localhost:27017")
	client, err := mongo.Connect(context.Background(), clientOptions)
	if err != nil {
		panic(err)
	}
	collection = client.Database("procurementdb").Collection("purchaseorders")
}
